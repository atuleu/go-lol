package xlol

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"strconv"
	"strings"
)

// A ReplayServer can serve over http a replay.
type ReplayServer struct {
	loader             ReplayDataLoader
	r                  *Replay
	startStreamChunk   ChunkID
	metadataRequester  chan GameMetadata
	chunkInfoRequester chan LastChunkInfo
	finish             chan struct{}
	listener           net.Listener
}

// NewReplayServer initializes a ReplayServer from data located somewhere
func NewReplayServer(loader ReplayDataLoader) (*ReplayServer, error) {
	res := &ReplayServer{
		loader: loader,
	}
	if loader == nil {
		return nil, fmt.Errorf("Empty loader")
	}
	var err error
	res.r, err = LoadReplay(loader)
	if err != nil {
		return nil, err
	}

	for _, c := range res.r.Chunks {
		if int(c.ID) < res.r.MetaData.StartGameChunkID {
			continue
		}
		if c.KeyFrame == 0 {
			continue
		}
		res.startStreamChunk = c.ID
		break
	}

	return res, nil
}

// EncryptionKey returns the encryption key used to encrypt the game
// data.
func (h *ReplayServer) EncryptionKey() string {
	return h.r.EncryptionKey
}

func (h *ReplayServer) checkGameKey(parts []string) bool {
	if len(parts) < 3 {
		return false
	}
	return parts[1] == h.r.MetaData.GameKey.PlatformID &&
		parts[2] == fmt.Sprintf("%d", h.r.MetaData.GameKey.ID)
}

func (h *ReplayServer) getParam(parts []string) (int, bool) {
	if h.checkGameKey(parts) == false {
		return 0, false
	}

	if len(parts) != 5 || parts[4] != "token" {
		return 0, false
	}
	res, err := strconv.ParseInt(parts[3], 10, 64)
	if err != nil {
		return 0, false
	}
	return int(res), true
}

type restFunctionHandler func(*ReplayServer, []string, http.ResponseWriter, *http.Request)

func handleVersion(h *ReplayServer, parts []string, w http.ResponseWriter, req *http.Request) {
	w.Header()["Content-Type"] = []string{"text/plain"}
	_, err := io.Copy(w, bytes.NewBuffer([]byte(h.r.Version)))
	if err != nil {
		panic(err)
	}
}

func (h *ReplayServer) generateMetadata(currentChunk ChunkID) GameMetadata {
	res := h.r.MetaData
	res.ClientBackFetchingEnabled = true
	var kfid KeyFrameID = -1
	for cid := h.startStreamChunk; cid <= currentChunk; cid++ {
		c := h.r.Chunks[h.r.chunksByID[cid]]
		res.PendingAvailableChunkInfo = append(res.PendingAvailableChunkInfo, c.ChunkInfo)
		if c.KeyFrame != kfid {
			kf := h.r.KeyFrames[h.r.keyframeByID[c.KeyFrame]]
			kfid = kf.ID
			res.PendingAvailableKeyFrameInfo = append(res.PendingAvailableKeyFrameInfo, kf.KeyFrameInfo)
		}
	}
	return res
}

func (h *ReplayServer) generateLastChunkInfo(currentChunk ChunkID) LastChunkInfo {
	c := h.r.Chunks[h.r.chunksByID[currentChunk]]
	kf := h.r.KeyFrames[h.r.keyframeByID[c.KeyFrame]]
	return LastChunkInfo{
		ID:                   currentChunk,
		AssociatedKeyFrameID: c.KeyFrame,
		NextChunkID:          kf.NextChunkID,
		AvailableSince:       0,
		EndStartupChunkID:    ChunkID(h.r.MetaData.EndStartupChunkID),
		StartGameChunkID:     ChunkID(h.r.MetaData.StartGameChunkID),
		EndGameChunkID:       ChunkID(h.r.MetaData.EndGameChunkID),
		NextAvailableChunk:   0,
	}
}

func handleGetMetadata(h *ReplayServer, parts []string, w http.ResponseWriter, req *http.Request) {
	_, ok := h.getParam(parts)
	if ok == false {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	w.Header()["Content-Type"] = []string{"application/json"}
	data, err := json.Marshal(<-h.metadataRequester)
	if err != nil {
		panic(err)
	}
	_, err = io.Copy(w, bytes.NewBuffer(data))
	if err != nil {
		panic(err)
	}
}

func handleGetLastChunkInfo(h *ReplayServer, parts []string, w http.ResponseWriter, req *http.Request) {
	_, ok := h.getParam(parts)
	if ok == false {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	w.Header()["Content-Type"] = []string{"application/json"}

	data, err := json.Marshal(<-h.chunkInfoRequester)
	if err != nil {
		panic(err)
	}
	_, err = io.Copy(w, bytes.NewBuffer(data))
	if err != nil {
		panic(err)
	}

}

func handleGetDataChunk(h *ReplayServer, parts []string, w http.ResponseWriter, req *http.Request) {
	param, ok := h.getParam(parts)
	if ok == false {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	r, err := h.loader.OpenChunk(ChunkID(param))
	w.Header()["Content-Type"] = []string{"application/octet-stream"}
	_, err = io.Copy(w, r)
	if err != nil {
		panic(err)
	}
}

func handleGetKeyFrame(h *ReplayServer, parts []string, w http.ResponseWriter, req *http.Request) {
	param, ok := h.getParam(parts)
	if ok == false {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	r, err := h.loader.OpenKeyFrame(KeyFrameID(param))
	w.Header()["Content-Type"] = []string{"application/octet-stream"}
	_, err = io.Copy(w, r)
	if err != nil {
		panic(err)
	}
}

func handleGetEndOfGame(h *ReplayServer, parts []string, w http.ResponseWriter, req *http.Request) {
	if h.checkGameKey(parts) != true || len(parts) != 4 || parts[3] != "null" {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	f, err := h.loader.OpenEndOfGameStats()
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	defer f.Close()
	w.Header()["Content-Type"] = []string{"application/octet-stream"}
	_, err = io.Copy(w, f)
	if err != nil {
		panic(err)
	}
}

var restMapping = map[SpectateFunction]restFunctionHandler{
	Version:          handleVersion,
	GetGameMetaData:  handleGetMetadata,
	GetLastChunkInfo: handleGetLastChunkInfo,
	EndOfGameStats:   handleGetEndOfGame,
	GetKeyFrame:      handleGetKeyFrame,
	GetGameDataChunk: handleGetDataChunk,
}

// version > text/plain
// json : application/json
// endofgame,chunk, keyframe application/octet-stream

func (h *ReplayServer) handle(w http.ResponseWriter, req *http.Request) {
	log.Printf("Got request %v", req)

	URL := req.URL.Path
	if strings.HasPrefix(URL, Prefix) == false {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	parts := strings.Split(strings.TrimPrefix(URL, Prefix), "/")
	if len(parts) == 0 {
		w.WriteHeader(http.StatusNotFound)
	}
	function := SpectateFunction(parts[0])

	handler, ok := restMapping[function]
	if ok == false {
		w.WriteHeader(http.StatusNotFound)
	}

	handler(h, parts, w, req)
}

// Close stops a running ReplayServer
func (h *ReplayServer) Close() error {
	if h.listener == nil {
		return fmt.Errorf("Server is not listening")
	}
	close(h.finish)
	return h.listener.Close()
}

func (h *ReplayServer) internLoop() {
	currentChunk := h.startStreamChunk
	shouldContinue := true
	currentChunkID := h.startStreamChunk

	for shouldContinue {
		select {
		case <-h.finish:
			shouldContinue = false
		case h.metadataRequester <- h.generateMetadata(currentChunk):
			fallthrough
		case h.chunkInfoRequester <- h.generateLastChunkInfo(currentChunk):
			//TODO start first time the ticker
			//TODO : add the ticker case
		}
	}

	// this will close pending request
	close(h.metadataRequester)
	close(h.chunkInfoRequester)
}

// ListenAndServe starts an http Server on the given address to show
// the replay
func (h *ReplayServer) ListenAndServe(addr string) error {
	//we must start intern loop for serving data over time
	var err error
	h.listener, err = net.Listen("tcp", addr)
	if err != nil {
		return err
	}

	h.metadataRequester = make(chan GameMetadata)
	h.chunkInfoRequester = make(chan LastChunkInfo)
	h.finish = make(chan struct{})
	go h.internLoop()

	return http.Serve(h.listener, http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		h.handle(w, req)
	}))
}
